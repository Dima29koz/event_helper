import uuid
from datetime import datetime
from time import time
from typing import Optional

import jwt
from flask import current_app
from sqlalchemy.exc import IntegrityError
from werkzeug.security import generate_password_hash, check_password_hash

from server.app import db, jwt_manager
from server.common.exceptions import MemberWithGivenUserIDExists
from server.utils.time import date_from_str
from server.common.enums import Role, ProductState


@jwt_manager.user_identity_loader
def user_identity_lookup(user):
    return user.id


@jwt_manager.user_lookup_loader
def user_lookup_callback(_jwt_header, jwt_data):
    return User.get_by_id(jwt_data.get("sub"))


def add(db_object):
    try:
        db.session.add(db_object)
        db.session.commit()
    except Exception as e:
        print(e)
        db.session.rollback()
        raise


def delete_obj(db_object):
    try:
        db.session.delete(db_object)
        db.session.commit()
    except Exception as e:
        print(e)
        db.session.rollback()
        raise


class User(db.Model):
    """User model

    :cvar id: autogenerated user id
    :type id: int
    :cvar username: unique username
    :type username: str
    :cvar full_name: full name
    :type full_name: str
    :cvar email: user email
    :type email: str
    :cvar phone: users phone number
    :type phone: str
    :cvar contacts: any other user contacts
    :type contacts: str
    :cvar is_email_verified: True after verifying email
    :type is_email_verified: bool
    :cvar pwd: hash of users password
    :type pwd: str
    :cvar timestamp: account creation date
    :type timestamp: datetime

    """

    def __init__(self, user_data: dict):
        self.username = user_data.get('username')
        self.full_name = user_data.get('full_name')
        self.email = user_data.get('email')
        self.phone = user_data.get('phone')
        self.contacts = user_data.get('contacts')
        self.pwd = generate_password_hash(user_data.get('pwd'))

    __tablename__ = 'user'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    full_name = db.Column(db.String(50), nullable=False)
    email = db.Column(db.String(50), nullable=False)
    phone = db.Column(db.String(12))
    contacts = db.Column(db.String(100))
    is_email_verified = db.Column(db.Boolean, default=False)
    pwd = db.Column(db.String(256), nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return self.username

    def check_password(self, password: str):
        """
        Verified users password.

        :param password: user password
        :type password: str
        :return: result of verification
        :rtype: bool
        """
        return check_password_hash(self.pwd, password)

    def set_email(self, new_email: str):
        self.email = new_email
        self.is_email_verified = False
        db.session.commit()

    def set_name(self, new_name: str):
        self.username = new_name
        db.session.commit()

    def set_pwd(self, new_pwd: str):
        self.pwd = generate_password_hash(new_pwd)
        db.session.commit()

    def verify_email(self):
        self.is_email_verified = True
        db.session.commit()

    def get_token(self, token_type: str, expires_in=600):
        return jwt.encode(
            {token_type: self.id, 'exp': time() + expires_in},
            current_app.config['SECRET_KEY'],
            algorithm='HS256'
        )

    def get_events_where_member(self):
        return [(member.event, {'role': member.role}) for member in self.members]

    @classmethod
    def verify_token(cls, token: str, token_type: str):
        try:
            user_id = jwt.decode(token, current_app.config['SECRET_KEY'], algorithms=['HS256'])[token_type]
        except Exception as _:
            return
        return cls.get_by_id(user_id)

    @classmethod
    def get_by_id(cls, user_id: int) -> Optional['User']:
        return cls.query.filter_by(id=user_id).first()

    @classmethod
    def get_by_username(cls, username: str) -> Optional['User']:
        return cls.query.filter_by(username=username).first()

    @classmethod
    def create(cls, user_data: dict) -> Optional['User']:
        """creates User if username is available"""
        if cls.get_by_username(user_data.get('username')):
            return
        user = User(user_data)
        add(user)
        return user


class EventMember(db.Model):
    """EventMember model

    :cvar id: autogenerated event member id
    :type id: int
    :cvar nickname: event member`s nickname
    :type nickname: str
    :cvar days_amount: days amount on event
    :type days_amount: int
    :cvar date_from: date when member arrive to event
    :type date_from: datetime
    :cvar date_to: date when member leaves event
    :type date_to: datetime
    :cvar is_drinker: describes if member is drinker
    :type is_drinker: bool
    :cvar is_involved: describes if member will arrive
    :type is_involved: bool
    :cvar money_impact: describes members money impact
    :type money_impact: float
    :cvar role: members role on event
    :type role: Role
    :cvar user_id: User foreign key
    :type user_id: int
    :cvar event_id: Event foreign key
    :type event_id: int

    :cvar user: user object
    :type user: User

    """

    def __init__(self, member_data: dict):
        self.nickname = member_data.get('nickname')
        self.days_amount = member_data.get('days_amount')
        self.date_from = date_from_str(member_data.get('date_from'))
        self.date_to = date_from_str(member_data.get('date_to'))
        self.is_drinker = member_data.get('is_drinker')
        self.is_involved = member_data.get('is_involved', True)
        self.role = Role[member_data.get('role')]
        self.user_id = member_data.get('user_id')

    __tablename__ = 'event_member'
    id = db.Column(db.Integer(), primary_key=True)
    nickname = db.Column(db.String(50), nullable=False)
    days_amount = db.Column(db.Integer(), nullable=False)
    date_from = db.Column(db.DateTime)
    date_to = db.Column(db.DateTime)
    is_drinker = db.Column(db.Boolean, default=False)
    is_involved = db.Column(db.Boolean, default=True)
    money_impact = db.Column(db.Float(), default=0)
    role = db.Column(db.Enum(Role), nullable=False)
    user_id = db.Column(db.Integer(), db.ForeignKey('user.id'))
    event_id = db.Column(db.Integer(), db.ForeignKey('event.id', ondelete="CASCADE"))

    user = db.relationship("User", foreign_keys=[user_id], backref=db.backref('members', lazy=True))

    def __repr__(self):
        return self.nickname

    @classmethod
    def get_by_id(cls, member_id: int) -> Optional['EventMember']:
        return cls.query.filter_by(id=member_id).first()

    def delete(self):
        member_id = self.id
        delete_obj(self)
        return member_id

    def set_money_impact(self, value: float):
        self.money_impact = value
        db.session.commit()


class Event(db.Model):
    """Event model

    :cvar id: autogenerated event id
    :type id: int
    :cvar key: event key
    :type key: str
    :cvar title: event title
    :type title: str
    :cvar description: event description
    :type description: str
    :cvar date_start: event start date
    :type date_start: datetime
    :cvar date_end: event end date
    :type date_end: datetime
    :cvar date_tz: timezone of event in format: [Â±0000]
    :type date_tz: str
    :cvar cost_reduction_factor: describes percent for cost reduction factor per day
    :type cost_reduction_factor: int
    :cvar creator_id: User foreign key
    :type creator_id: int

    :cvar creator: creator User object
    :type creator: User
    :cvar location: event location object
    :type location: EventLocation
    :cvar members: event members
    :type members: list[EventMember]
    :cvar products: event products
    :type products: list[Product]
    """

    def __init__(self, event_data: dict, creator: User):
        self.key = uuid.uuid4().hex
        self.title = event_data.get('title')
        self.description = event_data.get('description')
        self.date_start = date_from_str(event_data.get('date_start'))
        self.date_end = date_from_str(event_data.get('date_end'))
        self.date_tz = event_data.get('timezone')
        self.cost_reduction_factor = event_data.get('cost_reduction_factor')

        self.creator = creator
        self.location = EventLocation(event_data.get('location'))

        add(self)

    __tablename__ = 'event'
    id = db.Column(db.Integer(), primary_key=True)
    key = db.Column(db.String(50), nullable=False)
    title = db.Column(db.String(50), nullable=False)
    description = db.Column(db.UnicodeText)
    date_start = db.Column(db.DateTime, nullable=False)
    date_end = db.Column(db.DateTime, nullable=False)
    date_tz = db.Column(db.String(5), nullable=False)
    cost_reduction_factor = db.Column(db.Integer, default=25, nullable=False)
    creator_id = db.Column(db.Integer(), db.ForeignKey('user.id'), nullable=False)

    creator = db.relationship("User", foreign_keys=[creator_id], backref=db.backref('events', lazy=True))
    location = db.relationship(
        "EventLocation",
        uselist=False,
        cascade="all, delete",
        passive_deletes=True
    )
    members = db.relationship(
        "EventMember",
        cascade="all, delete",
        passive_deletes=True,
        backref=db.backref('event', lazy=True)
    )
    products = db.relationship(
        "Product",
        cascade="all, delete",
        passive_deletes=True,
        backref=db.backref('event', lazy=True)
    )

    def __repr__(self):
        return self.title

    def add_member(self, member_data: dict):
        if self.has_member(member_data.get('user_id')):
            raise MemberWithGivenUserIDExists()

        try:
            member = EventMember(member_data)
        except (KeyError, ValueError):
            return
        self.members.append(member)
        db.session.commit()
        return member

    def add_product(self, product_data: dict):
        added_products, updated_products = self.add_products([product_data])
        return added_products[0] if added_products else None, updated_products[0] if updated_products else None

    def add_products(self, products: list[dict]):
        added_products = []
        updated_products = []
        for product_data in products:
            product = self.get_not_bought_product(product_data.get('product_id'))
            if product:
                product.amount = product_data.get('amount')
                updated_products.append(product)
            else:
                product = Product(product_data)
                added_products.append(product)
                self.products.append(product)
        db.session.commit()
        return added_products, updated_products

    def get_member_by_id(self, member_id: int) -> EventMember | None:
        return db.session.scalars(
            db.select(EventMember)
            .join(EventMember.event)
            .where(EventMember.id == member_id)
            .where(Event.id == self.id)
        ).first()

    def get_product_by_id(self, product_id: int) -> Optional['Product']:
        return db.session.scalars(
            db.select(Product)
            .join(Product.event)
            .where(Product.id == product_id)
            .where(Event.id == self.id)
        ).first()

    def get_member_by_user(self, user: User) -> EventMember | None:
        return db.session.scalars(
            db.select(EventMember)
            .join(EventMember.event)
            .where(EventMember.user == user)
            .where(Event.id == self.id)
        ).first()

    def get_not_bought_product(self, base_product_id: int) -> Optional['Product']:
        return db.session.scalars(
            db.select(Product)
            .join(Product.event)
            .where(Product.product_id == base_product_id)
            .where(Product.state != ProductState.bought)
            .where(Event.id == self.id)
        ).first()

    def has_member(self, user_id: int | None) -> bool:
        if not user_id:
            return False
        return any(member.user_id == user_id for member in self.members)

    def has_not_bought_product(self, base_product_id: int) -> bool:
        return any(
            product.product_id == base_product_id and product.state != ProductState.bought
            for product in self.products
        )

    @classmethod
    def get_by_id(cls, event_id: int) -> Optional['Event']:
        return cls.query.filter_by(id=event_id).first()

    @classmethod
    def get_by_key(cls, event_key: str) -> Optional['Event']:
        return cls.query.filter_by(key=event_key).first()

    @classmethod
    def create(cls, event_data: dict, creator: User) -> Optional['Event']:
        event = Event(event_data, creator)
        return event

    def delete(self):
        event_id, key = self.id, self.key
        delete_obj(self)
        return event_id, key


class Location(db.Model):
    """Location model

    :cvar id: autogenerated location id
    :type id: int
    :cvar name: location name
    :type name: str
    :cvar address: location address
    :type address: str
    :cvar geo: location geo
    :type geo: str
    :cvar maps_link: location maps link
    :type maps_link: str
    :cvar description: location description
    :type description: str
    :cvar creator_id: User foreign key
    :type creator_id: int

    :cvar creator: location creator
    :type creator: User

    """

    def __init__(self, location_data: dict, creator: User):
        self.name = location_data.get('name')
        self.address = location_data.get('address')
        self.geo = location_data.get('geo')
        self.maps_link = location_data.get('maps_link')
        self.description = location_data.get('description')
        self.creator = creator

        add(self)

    __tablename__ = 'location'
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    address = db.Column(db.String(500), nullable=False)
    geo = db.Column(db.String(100), nullable=False)
    maps_link = db.Column(db.String(100), nullable=False)
    description = db.Column(db.UnicodeText)
    creator_id = db.Column(db.Integer(), db.ForeignKey('user.id'), nullable=False)

    creator = db.relationship("User", foreign_keys=[creator_id], backref=db.backref('locations', lazy=True))

    def __repr__(self):
        return self.address

    def update(self, location_data: dict):
        self.name = location_data.get('name')
        self.address = location_data.get('address')
        self.geo = location_data.get('geo')
        self.maps_link = location_data.get('maps_link')
        self.description = location_data.get('description')

        db.session.commit()

    def delete(self):
        delete_obj(self)

    @classmethod
    def get_by_id(cls, location_id: int) -> Optional['Location']:
        return cls.query.filter_by(id=location_id).first()

    @classmethod
    def validate_id_to_user(cls, location_id: int, user: User) -> Optional['Location']:
        """Checks if location id exists and user is location owner"""
        location = cls.get_by_id(location_id)
        if location and location in user.locations:
            return location


class EventLocation(db.Model):
    """Event Location model

    :cvar id: autogenerated location id
    :type id: int
    :cvar name: location name
    :type name: str
    :cvar address: location address
    :type address: str
    :cvar geo: location geo
    :type geo: str
    :cvar maps_link: location maps link
    :type maps_link: str
    :cvar description: location description
    :type description: str
    :cvar event_id: Event foreign key
    :type event_id: int

    """

    def __init__(self, location: dict):
        self.name = location.get('name')
        self.address = location.get('address')
        self.geo = location.get('geo')
        self.maps_link = location.get('maps_link')
        self.description = location.get('description')

    __tablename__ = 'event_location'
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    address = db.Column(db.String(500), nullable=False)
    geo = db.Column(db.String(100), nullable=False)
    maps_link = db.Column(db.String(100), nullable=False)
    description = db.Column(db.UnicodeText)
    event_id = db.Column(db.Integer(), db.ForeignKey('event.id', ondelete="CASCADE"), nullable=False)

    def __repr__(self):
        return self.name


class ProductCategory(db.Model):
    """ProductCategory model

    :cvar id: autogenerated ProductCategory id
    :type id: int
    :cvar name: ProductCategory name
    :type name: str

    """

    def __init__(self, name: str):
        self.name = name

    __tablename__ = 'product_category'
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(50), nullable=False, unique=True)

    def __repr__(self):
        return self.name

    @classmethod
    def get_by_name(cls, name: str) -> Optional['ProductCategory']:
        return cls.query.filter_by(name=name).first()

    @classmethod
    def create(cls, name: str) -> 'ProductCategory':
        """creates ProductCategory if name not exists else returns category"""
        category = cls.get_by_name(name)
        if category:
            return category

        category = ProductCategory(name)
        add(category)
        return category


class ProductType(db.Model):
    """ProductType model

    :cvar id: autogenerated ProductType id
    :type id: int
    :cvar name: ProductType name
    :type name: str

    """

    def __init__(self, name: str):
        self.name = name

    __tablename__ = 'product_type'
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(50), nullable=False, unique=True)

    def __repr__(self):
        return self.name

    @classmethod
    def get_by_name(cls, name: str) -> Optional['ProductType']:
        return cls.query.filter_by(name=name).first()

    @classmethod
    def create(cls, name: str) -> 'ProductType':
        """creates ProductType if name not exists else returns type"""
        p_type = cls.get_by_name(name)
        if p_type:
            return p_type

        p_type = ProductType(name)
        add(p_type)
        return p_type


class ProductUnit(db.Model):
    """ProductUnit model

    :cvar id: autogenerated ProductUnit id
    :type id: int
    :cvar name: ProductUnit name
    :type name: str

    """

    def __init__(self, name: str):
        self.name = name

    __tablename__ = 'product_unit'
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(50), nullable=False, unique=True)

    def __repr__(self):
        return self.name

    @classmethod
    def get_by_name(cls, name: str) -> Optional['ProductUnit']:
        return cls.query.filter_by(name=name).first()

    @classmethod
    def create(cls, name: str) -> 'ProductUnit':
        """creates ProductUnit if name not exists else returns unit"""
        unit = cls.get_by_name(name)
        if unit:
            return unit

        unit = ProductUnit(name)
        add(unit)
        return unit


class BaseProduct(db.Model):
    """BaseProduct model

    :cvar id: autogenerated BaseProduct id
    :type id: int
    :cvar name: BaseProduct name
    :type name: str
    :cvar category_id: ProductCategory foreign key
    :type category_id: int
    :cvar type_id: ProductType foreign key
    :type type_id: int
    :cvar unit_id: ProductUnit foreign key
    :type unit_id: int
    :cvar price_supposed: supposed product price
    :type price_supposed: float

    """

    def __init__(self, product_data: dict):
        self.name = product_data.get('name')
        self.category_id = product_data.get('category_id')
        self.type_id = product_data.get('type_id')
        self.unit_id = product_data.get('unit_id')
        self.price_supposed = product_data.get('price_supposed', 0)

    __tablename__ = 'base_product'
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(50), nullable=False, unique=True)
    category_id = db.Column(db.Integer(), db.ForeignKey('product_category.id'), nullable=False)
    type_id = db.Column(db.Integer(), db.ForeignKey('product_type.id'), nullable=False)
    unit_id = db.Column(db.Integer(), db.ForeignKey('product_unit.id'), nullable=False)
    price_supposed = db.Column(db.Float())

    category = db.relationship("ProductCategory", foreign_keys=[category_id],
                               backref=db.backref('base_products', lazy=True))
    type = db.relationship("ProductType", foreign_keys=[type_id], backref=db.backref('base_products', lazy=True))
    unit = db.relationship("ProductUnit", foreign_keys=[unit_id])

    def __repr__(self):
        return self.name

    @classmethod
    def get_by_name(cls, name: str) -> Optional['BaseProduct']:
        return cls.query.filter_by(name=name).first()

    @classmethod
    def get_by_id(cls, product_id: int) -> Optional['BaseProduct']:
        return cls.query.filter_by(id=product_id).first()

    @classmethod
    def create(cls, product_data: dict) -> Optional['BaseProduct']:
        """creates BaseProduct if name not exists else returns baseProduct"""
        product = cls.get_by_name(product_data.get('name'))
        if product:
            return product

        try:
            product = BaseProduct(product_data)
            add(product)
            return product
        except IntegrityError as _:
            return


class Product(db.Model):
    """Product model

    :cvar id: autogenerated Product id
    :type id: int
    :cvar product_id: BaseProduct foreign key
    :type product_id: int
    :cvar state: product state
    :type state: ProductState
    :cvar amount: amount of products
    :type amount: int
    :cvar price_final: product purchase price
    :type price_final: float
    :cvar description: product description
    :type description: str
    :cvar market: place of purchase
    :type market: str
    :cvar event_id: Event foreign key
    :type event_id: int

    """

    def __init__(self, product_data: dict):
        state = product_data.get('state', None)
        if state is None:
            state = ProductState.added
        else:
            state = ProductState[state]
        self.product_id = product_data.get('product_id')
        self.state = state
        self.amount = product_data.get('amount', 1)
        self.price_final = round(float(product_data.get('price_final', 0)), 2)
        self.description = product_data.get('description', None)
        self.market = product_data.get('market', None)

    __tablename__ = 'product'
    id = db.Column(db.Integer(), primary_key=True)
    product_id = db.Column(db.Integer(), db.ForeignKey('base_product.id'), nullable=False)
    state = db.Column(db.Enum(ProductState), nullable=False)
    amount = db.Column(db.Integer(), nullable=False)
    price_final = db.Column(db.Float())
    description = db.Column(db.UnicodeText)
    market = db.Column(db.String(50))
    event_id = db.Column(db.Integer(), db.ForeignKey('event.id', ondelete="CASCADE"))

    base_product = db.relationship("BaseProduct", foreign_keys=[product_id])

    def __repr__(self):
        return str(self.base_product) + ' - ' + self.state.name

    def delete(self):
        product_id = self.id
        delete_obj(self)
        return product_id
